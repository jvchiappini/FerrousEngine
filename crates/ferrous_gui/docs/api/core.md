<!--
Core abstractions and API surface of the `ferrous_gui` crate.
This document is intended for developers who want to understand how to
integrate the UI layer or extend it with new widget types.
-->

# Core API

The `ferrous_gui` crate is built around a small set of traits and helper
types that are deliberately decoupled from rendering backends and
windowing libraries.  This allows the core logic to remain simple, while
the surrounding engine provides concrete conversions to GPU commands or
text drawing.

## `Widget` trait

The fundamental interface that every visual element implements:

```rust
pub trait Widget {
    /// Append one or more `RenderCommand` instances that describe what
    /// the widget wishes to draw during the next frame.
    fn collect(&self, cmds: &mut Vec<RenderCommand>);

    /// Basic hit test used for focus/navigation.  Coordinates are in
    /// window space.  The default implementation returns `false`.
    fn hit(&self, _mx: f64, _my: f64) -> bool { false }

    /// Called when a mouse button changes state (pressed/released).
    /// Implementations should update hover/pressed/dragging state as
    /// appropriate.  Default is a no-op.
    fn mouse_input(&mut self, _mx: f64, _my: f64, _pressed: bool) {}

    /// Called when the cursor moves.  Useful for hover effects or
    /// dragging behaviour.  Default is a no-op.
    fn mouse_move(&mut self, _mx: f64, _my: f64) {}

    /// Keyboard input forwarded to the widget that currently has focus.
    /// `text` contains any text generated by the key, while `key` is an
    /// optional `KeyCode` for non-text keys (e.g. backspace).  `pressed`
    /// indicates whether the key was pressed or released.  Default is a
    /// no-op.
    fn keyboard_input(&mut self, _text: Option<&str>, _key: Option<KeyCode>, _pressed: bool) {}
}
```

This trait is intentionally minimal; widgets maintain their own state and
decide how to render themselves.  The UI system never assumes anything
about a widget’s internal details, which makes it easy to author custom
controls in application code.

## `Canvas`

`Canvas` is a simple container that holds a heterogeneous collection of
boxed widgets.  It is responsible for focus management and for dispatching
input events to its children.

```rust
pub struct Canvas {
    children: Vec<Box<dyn Widget>>,
    focused: Option<usize>,
}
```

Key behaviour:

- **Adding widgets:** `Canvas::add(widget)` takes any type that
  implements `Widget` and stores it behind a `Box`.
- **Event routing:** `mouse_move` forwards movement to every child; the
  `mouse_input` method updates the focus index on press (first hit widget
  wins) and then delivers the event to all children.  Keyboard events are
  sent only to the focused child.
- **Rendering:** `collect(&mut cmds)` simply invokes `collect` on each
  child, aggregating their `RenderCommand`s.

## High‑level `Ui` helper

Most applications work with a `Ui` instance rather than interacting
directly with `Canvas`.  `Ui` wraps a `Canvas` and provides convenient
methods to integrate with the engine’s event loop and input state.

```rust
pub struct Ui {
    canvas: Canvas,
    viewport: Option<Rc<RefCell<ViewportWidget>>>,
}
```

### Typical usage

1. Construct a `Ui` and add widgets.
2. In the winit event loop, forward window events via
   `ui.handle_window_event(&event, &mut input_state)`; this keeps the
   engine input state in sync and dispatches to the widget tree.
3. During render, call `ui.draw(&mut quad_batch, &mut text_batch, Some(&font))`.

### Viewport support

The `Ui` exposes a small API for viewport widgets (used by the 3D view
in the editor):

- `register_viewport` stores a reference to a `ViewportWidget` and adds it
  to the canvas.
- `set_viewport_rect` updates the viewport’s rectangle, easing handling
  of resize events.
- `viewport_focused()` returns whether the registered viewport currently
  has input focus; useful for letting the rest of the engine know when to
  capture the mouse or keyboard.

## RenderCommand

Widgets produce instances of `RenderCommand` (defined in the root of the
crate) which describe primitive drawing operations such as quads or text.
The renderer within `ferrous_renderer` converts these generic commands
into the appropriate GPU batches.  This indirection keeps the UI layer
renderer‑agnostic.

---

With these core abstractions in place, the remainder of the documentation
focuses on concrete widgets and the layout subsystem.
