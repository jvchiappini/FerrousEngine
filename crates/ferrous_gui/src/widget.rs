use crate::layout::{Node, RenderCommand};
use ferrous_core::InputState;
use winit::keyboard::KeyCode;

/// Cualquier elemento de la interfaz que pueda "dibujarse".
///
/// En lugar de acoplarse al renderer, la abstracción devuelve una lista de
/// `RenderCommand` genéricos. Más adelante el código que use la UI puede
/// convertirlos a `GuiBatch` y `TextBatch` según corresponda.
pub trait Widget {
    /// collect render commands for this widget (called during draw pass)
    fn collect(&self, cmds: &mut Vec<RenderCommand>);

    /// simple hit test used by focus/navigation; coordinates are in window
    /// space (same as the various `hit` helpers defined on specific widgets).
    /// The default implementation returns `false` which means the widget is
    /// not interactable.
    fn hit(&self, _mx: f64, _my: f64) -> bool {
        false
    }

    /// called when a mouse button changes state (pressed or released). The
    /// coordinates correspond to the event location. Widgets can update their
    /// internal state (hover, pressed, dragging, focus, etc.) here. The
    /// default implementation does nothing.
    fn mouse_input(&mut self, _mx: f64, _my: f64, _pressed: bool) {}

    /// called when the cursor moves. Useful for updating hover or dragging
    /// behaviour. The default implementation does nothing.
    fn mouse_move(&mut self, _mx: f64, _my: f64) {}

    /// keyboard event forwarded to whichever widget currently has focus.
    /// `text` contains any Unicode text generated by the key (e.g. from
    /// `ReceivedCharacter` events) while `key` is an optional keycode that
    /// can be used for handling non-text keys such as backspace. `pressed`
    /// indicates whether the key was pressed (true) or released (false).
    /// The default implementation is a no-op.
    fn keyboard_input(&mut self, _text: Option<&str>, _key: Option<KeyCode>, _pressed: bool) {}
}

/// Contenedor genérico que alberga varios widgets y los dibuja por orden.
pub struct Canvas {
    children: Vec<Box<dyn Widget>>,
    /// index of currently focused child (used for keyboard events). The
    /// value is `None` when no widget has focus.
    focused: Option<usize>,
}

impl Canvas {
    pub fn new() -> Self {
        Self {
            children: Vec::new(),
            focused: None,
        }
    }

    pub fn add(&mut self, widget: impl Widget + 'static) {
        self.children.push(Box::new(widget));
    }

    pub fn collect(&self, cmds: &mut Vec<RenderCommand>) {
        for child in &self.children {
            child.collect(cmds);
        }
    }

    /// route a mouse-move event to all children; this is important for
    /// things like slider dragging or hover state. It does **not** change
    /// focus.
    pub fn mouse_move(&mut self, mx: f64, my: f64) {
        for child in &mut self.children {
            child.mouse_move(mx, my);
        }
    }

    /// handle mouse button press/release. On press we update the focus
    /// index by performing hit tests in order; the first widget hit becomes
    /// focused and all others lose focus. After focus is determined we
    /// forward the input event to every child (allowing sliders/buttons to
    /// respond even if they are not focused).
    pub fn mouse_input(&mut self, mx: f64, my: f64, pressed: bool) {
        if pressed {
            self.focused = None;
            for (i, child) in self.children.iter_mut().enumerate() {
                if child.hit(mx, my) {
                    self.focused = Some(i);
                    break;
                }
            }
        }
        for child in &mut self.children {
            child.mouse_input(mx, my, pressed);
        }
    }

    /// forward keyboard events to the currently focused widget (if any).
    pub fn keyboard_input(&mut self, text: Option<&str>, key: Option<KeyCode>, pressed: bool) {
        if let Some(idx) = self.focused {
            if let Some(child) = self.children.get_mut(idx) {
                child.keyboard_input(text, key, pressed);
            }
        }
    }
}

/// Higher‑level UI object intended to be held by applications. It wraps a
/// [`Canvas`] and provides convenience helpers for routing `winit` events and
/// drawing the aggregated widget tree.
///
/// The goal is to let users write very little boilerplate: they create one
/// `Ui`, add widgets to it, and then in their event loop call
/// `ui.handle_window_event(&event, &mut input_state)` followed by
/// `ui.draw(...)` when rendering. The `Canvas` still does all the hard work
/// (focus, hit tests, etc.), but the application no longer needs to know the
/// details of which methods to call for each type of event.
pub struct Ui {
    canvas: Canvas,
    /// optional handle to a viewport widget previously registered via
    /// `register_viewport`; this allows the UI to expose helpers for
    /// updating the rectangle without the caller needing to hold their own
    /// reference.
    viewport: Option<std::rc::Rc<std::cell::RefCell<ViewportWidget>>>,
}

impl Ui {
    pub fn new() -> Self {
        Ui {
            canvas: Canvas::new(),
            viewport: None,
        }
    }

    /// Add a widget to the UI tree.
    pub fn add(&mut self, widget: impl Widget + 'static) {
        self.canvas.add(widget);
    }

    /// Convenience helper for viewport widgets. The passed reference is stored
    /// internally and also added to the canvas; later calls to
    /// `set_viewport_rect` will update the stored widget so the application
    /// does not need to keep its own copy.
    pub fn register_viewport(&mut self, vp: std::rc::Rc<std::cell::RefCell<ViewportWidget>>) {
        self.viewport = Some(vp.clone());
        self.add(vp);
    }

    /// Update the dimensions of the registered viewport widget, if any. This
    /// is mostly a convenience so that applications don't need to hold a
    /// separate reference just to propagate resize events.
    pub fn set_viewport_rect(&mut self, x: f32, y: f32, w: f32, h: f32) {
        if let Some(vp) = &self.viewport {
            vp.borrow_mut().rect = [x, y, w, h];
        }
    }

    /// Returns `true` if a viewport widget has been registered and currently
    /// holds focus. Useful for applications that want to treat the viewport
    /// differently (e.g. capture mouse/keyboard for 3D camera).
    pub fn viewport_focused(&self) -> bool {
        self.viewport
            .as_ref()
            .map(|vp| vp.borrow().focused)
            .unwrap_or(false)
    }

    /// Handle a winit window event, updating both the provided `InputState`
    /// (so that the rest of the engine sees the mouse position/keys) and
    /// dispatching the event to the widget tree.
    pub fn handle_window_event(
        &mut self,
        event: &winit::event::WindowEvent,
        input: &mut InputState,
    ) {
        match event {
            winit::event::WindowEvent::CursorMoved { position, .. } => {
                input.set_mouse_position(position.x, position.y);
                self.canvas.mouse_move(position.x, position.y);
            }
            winit::event::WindowEvent::MouseInput { state, button, .. } => {
                let pressed = *state == winit::event::ElementState::Pressed;
                // update engine input state so the 3D camera code can see
                // which button is down (right button is used for orbit).
                input.update_mouse_button(*button, pressed);
                let (mx, my) = input.mouse_position();
                // propagate to canvas as before; widgets don't care which
                // button was pressed (they simply treat any press as a
                // potential click), so we continue to ignore the `button`
                // here.
                self.canvas.mouse_input(mx, my, pressed);
            }
            winit::event::WindowEvent::KeyboardInput { event, .. } => {
                let winit::event::KeyEvent {
                    physical_key,
                    state,
                    text,
                    ..
                } = event;
                if let winit::keyboard::PhysicalKey::Code(code) = physical_key {
                    input.update_key(*code, *state == winit::event::ElementState::Pressed);
                }
                self.canvas.keyboard_input(
                    text.as_deref(),
                    if let winit::keyboard::PhysicalKey::Code(k) = physical_key {
                        Some(*k)
                    } else {
                        None
                    },
                    *state == winit::event::ElementState::Pressed,
                );
            }
            _ => {}
        }
    }

    /// Collect draw commands from the widget tree and convert them into the
    /// provided GUI/text batches. The `font` parameter is passed through to
    /// `RenderCommand::to_batches`, so `None` is valid when no font is
    /// available yet.
    pub fn draw(
        &self,
        quad_batch: &mut crate::renderer::GuiBatch,
        text_batch: &mut crate::renderer::TextBatch,
        font: Option<&ferrous_assets::font::Font>,
    ) {
        let mut cmds = Vec::new();
        self.canvas.collect(&mut cmds);
        for cmd in &cmds {
            cmd.to_batches(quad_batch, text_batch, font);
        }
    }

    /// Mutable access to the underlying canvas in case the user needs to
    /// perform more advanced operations (e.g. remove a widget).
    pub fn canvas_mut(&mut self) -> &mut Canvas {
        &mut self.canvas
    }
}

/// A lightweight widget representing a rectangular viewport area. The
/// widget does not draw anything itself, but it participates in the focus
/// system so that the rest of the application can know when the user has
/// clicked inside the 3D viewport and hence the viewport should capture
/// input instead of the UI.
#[derive(Debug, Clone)]
pub struct ViewportWidget {
    pub rect: [f32; 4],
    pub focused: bool,
}

impl ViewportWidget {
    pub fn new(x: f32, y: f32, w: f32, h: f32) -> Self {
        Self {
            rect: [x, y, w, h],
            focused: false,
        }
    }

    pub fn hit(&self, mx: f64, my: f64) -> bool {
        let x = mx as f32;
        let y = my as f32;
        x >= self.rect[0]
            && x <= self.rect[0] + self.rect[2]
            && y >= self.rect[1]
            && y <= self.rect[1] + self.rect[3]
    }
}

impl Widget for ViewportWidget {
    fn collect(&self, _cmds: &mut Vec<RenderCommand>) {
        // viewport doesn't render anything as part of the UI
    }

    fn hit(&self, mx: f64, my: f64) -> bool {
        self.hit(mx, my)
    }

    fn mouse_input(&mut self, mx: f64, my: f64, pressed: bool) {
        if pressed {
            self.focused = self.hit(mx, my);
        }
    }
}

// simple tests to ensure the canvas forwards draw calls
#[cfg(test)]
mod tests {
    use super::*;

    struct Dummy {
        called: std::cell::Cell<bool>,
    }

    impl Dummy {
        fn new() -> Self {
            Self {
                called: std::cell::Cell::new(false),
            }
        }
    }

    impl Widget for Dummy {
        fn collect(&self, cmds: &mut Vec<RenderCommand>) {
            self.called.set(true);
            // add a dummy quad command
            cmds.push(RenderCommand::Quad {
                rect: crate::layout::Rect {
                    x: 0.0,
                    y: 0.0,
                    width: 1.0,
                    height: 1.0,
                },
                color: [1.0, 1.0, 1.0, 1.0],
                radii: [0.0; 4],
                flags: 0,
            });
        }
    }

    #[test]
    fn canvas_propagates_draw() {
        let mut canvas = Canvas::new();
        let dummy = Dummy::new();
        canvas.add(dummy);
        let mut cmds = Vec::new();
        canvas.collect(&mut cmds);
        assert!(!cmds.is_empty());
    }
}

#[cfg(test)]
mod builder_tests {
    use super::*;
    use crate::layout::DisplayMode;

    #[test]
    fn column_builder_and_layout() {
        let ui = Column::new()
            .with_padding(20.0)
            .add_child(UiButton::new("Save").with_margin(5.0))
            .add_child(Text::new("Hello"));

        // convert to Node so we can compute layout
        let mut node: Node = ui.into();
        node.compute_layout(200.0, 100.0);

        // should be flex column => each child stacked vertically
        assert_eq!(node.style.display, DisplayMode::FlexColumn);
        assert!(node.children.len() == 2);
        // the first child should have x offset equal to padding+margin
        assert!(node.children[0].rect.x > 0.0);
    }
}

// -----------------------------------------------------------------------------
// helpers for declarative builder API

/// Contenedor de columnas flexibles.
///
/// ```rust
/// use ferrous_gui::{Column, UiButton, Text};
///
/// let ui = Column::new()
///     .with_padding(20.0)
///     .add_child(UiButton::new("Guardar").with_margin(5.0))
///     .add_child(Text::new("Usuario: Admin"));
///
/// // convertir a nodos y calcular layout en pantalla de 800x600
/// let mut root: ferrous_gui::Node = ui.into();
/// root.compute_layout(800.0, 600.0);
/// ```
pub struct Column(pub Node);

impl Column {
    pub fn new() -> Self {
        Column(Node::new().with_display(crate::layout::DisplayMode::FlexColumn))
    }

    pub fn with_padding(self, v: f32) -> Self {
        Column(self.0.with_padding(v))
    }

    pub fn with_margin(self, v: f32) -> Self {
        Column(self.0.with_margin(v))
    }

    pub fn add_child<T: Into<Node>>(mut self, child: T) -> Self {
        self.0 = self.0.add_child(child.into());
        self
    }
}

impl From<Column> for Node {
    fn from(c: Column) -> Node {
        c.0
    }
}

/// Contenedor de filas flexibles (alias a Column pero con dirección horizontal).
pub struct Row(pub Node);

impl Row {
    pub fn new() -> Self {
        Row(Node::new().with_display(crate::layout::DisplayMode::FlexRow))
    }

    pub fn with_padding(self, v: f32) -> Self {
        Row(self.0.with_padding(v))
    }

    pub fn add_child<T: Into<Node>>(mut self, child: T) -> Self {
        self.0 = self.0.add_child(child.into());
        self
    }
}

impl From<Row> for Node {
    fn from(r: Row) -> Node {
        r.0
    }
}

/// Botón simple con texto y color de fondo (construido como un nodo).
/// Este tipo forma parte de la API de construcción declarativa y no debe
/// confundirse con el widget interactivo definido en `button.rs`.
pub struct UiButton(pub Node);

impl UiButton {
    pub fn new(label: &str) -> Self {
        let mut n = Node::new();
        n = n.set_text(label);
        n = n.set_background([0.2, 0.2, 0.8, 1.0]);
        n = n.set_text_color([1.0, 1.0, 1.0, 1.0]);
        n = n.with_padding(5.0);
        n = n.with_alignment(crate::layout::Alignment::Center);
        UiButton(n)
    }

    pub fn with_margin(self, v: f32) -> Self {
        UiButton(self.0.with_margin(v))
    }

    pub fn with_padding(self, v: f32) -> Self {
        UiButton(self.0.with_padding(v))
    }
}

impl From<UiButton> for Node {
    fn from(b: UiButton) -> Node {
        b.0
    }
}

/// Texto estático.
pub struct Text(pub Node);

impl Text {
    pub fn new(content: &str) -> Self {
        let mut n = Node::new();
        n = n.set_text(content);
        Text(n)
    }

    pub fn with_margin(self, v: f32) -> Self {
        Text(self.0.with_margin(v))
    }
}

impl From<Text> for Node {
    fn from(t: Text) -> Node {
        t.0
    }
}

// make Node itself a widget so containers composed of nodes can be used as widgets
impl Widget for Node {
    fn collect(&self, cmds: &mut Vec<RenderCommand>) {
        self.collect_render_commands(cmds);
    }
}

// convenience impl so that shared references can be stored in a Canvas and
// updated by the application while still being drawn by the container. We
// delegate every method back to the inner object.
impl<T: Widget> Widget for std::rc::Rc<std::cell::RefCell<T>> {
    fn collect(&self, cmds: &mut Vec<RenderCommand>) {
        self.borrow().collect(cmds);
    }
    fn hit(&self, mx: f64, my: f64) -> bool {
        self.borrow().hit(mx, my)
    }
    fn mouse_input(&mut self, mx: f64, my: f64, pressed: bool) {
        self.borrow_mut().mouse_input(mx, my, pressed);
    }
    fn mouse_move(&mut self, mx: f64, my: f64) {
        self.borrow_mut().mouse_move(mx, my);
    }
    fn keyboard_input(
        &mut self,
        text: Option<&str>,
        key: Option<winit::keyboard::KeyCode>,
        pressed: bool,
    ) {
        self.borrow_mut().keyboard_input(text, key, pressed);
    }
}
