use crate::layout::{Node, RenderCommand};
use winit::keyboard::KeyCode;

/// Cualquier elemento de la interfaz que pueda "dibujarse".
///
/// En lugar de acoplarse al renderer, la abstracción devuelve una lista de
/// `RenderCommand` genéricos. Más adelante el código que use la UI puede
/// convertirlos a `GuiBatch` y `TextBatch` según corresponda.
pub trait Widget {
    /// collect render commands for this widget (called during draw pass)
    fn collect(&self, cmds: &mut Vec<RenderCommand>);

    /// simple hit test used by focus/navigation; coordinates are in window
    /// space (same as the various `hit` helpers defined on specific widgets).
    /// The default implementation returns `false` which means the widget is
    /// not interactable.
    fn hit(&self, _mx: f64, _my: f64) -> bool {
        false
    }

    /// called when a mouse button changes state (pressed or released). The
    /// coordinates correspond to the event location. Widgets can update their
    /// internal state (hover, pressed, dragging, focus, etc.) here. The
    /// default implementation does nothing.
    fn mouse_input(&mut self, _mx: f64, _my: f64, _pressed: bool) {}

    /// called when the cursor moves. Useful for updating hover or dragging
    /// behaviour. The default implementation does nothing.
    fn mouse_move(&mut self, _mx: f64, _my: f64) {}

    /// keyboard event forwarded to whichever widget currently has focus.
    /// `text` contains any Unicode text generated by the key (e.g. from
    /// `ReceivedCharacter` events) while `key` is an optional keycode that
    /// can be used for handling non-text keys such as backspace. `pressed`
    /// indicates whether the key was pressed (true) or released (false).
    /// The default implementation is a no-op.
    fn keyboard_input(&mut self, _text: Option<&str>, _key: Option<KeyCode>, _pressed: bool) {}

    /// Optional rectangle occupied by the widget in window coordinates.  The
    /// default implementation returns `None`, meaning the container cannot
    /// infer any size from this widget.  Widgets that maintain a `rect`
    /// field (e.g. `Button`, `Slider`, `Node` wrappers) should override
    /// this and return `Some(rect)` so that parent containers can perform
    /// auto-sizing.
    fn bounding_rect(&self) -> Option<[f32; 4]> {
        None
    }
}

// make Node itself a widget so containers composed of nodes can be used as widgets
impl Widget for Node {
    fn collect(&self, cmds: &mut Vec<RenderCommand>) {
        self.collect_render_commands(cmds);
    }

    fn bounding_rect(&self) -> Option<[f32; 4]> {
        Some([self.rect.x, self.rect.y, self.rect.width, self.rect.height])
    }
}

// convenience impl so that shared references can be stored in a Canvas and
// updated by the application while still being drawn by the container. We
// delegate every method back to the inner object.
impl<T: Widget> Widget for std::rc::Rc<std::cell::RefCell<T>> {
    fn collect(&self, cmds: &mut Vec<RenderCommand>) {
        self.borrow().collect(cmds);
    }
    fn hit(&self, mx: f64, my: f64) -> bool {
        self.borrow().hit(mx, my)
    }
    fn mouse_input(&mut self, mx: f64, my: f64, pressed: bool) {
        self.borrow_mut().mouse_input(mx, my, pressed);
    }
    fn mouse_move(&mut self, mx: f64, my: f64) {
        self.borrow_mut().mouse_move(mx, my);
    }
    fn keyboard_input(
        &mut self,
        text: Option<&str>,
        key: Option<winit::keyboard::KeyCode>,
        pressed: bool,
    ) {
        self.borrow_mut().keyboard_input(text, key, pressed);
    }
}
